package ua.com.alevel.DataStructure;

import java.util.ArrayList;
import java.util.List;

public class LambdaExpresions {

    public static void main(String[] args) {

        test();
    }

    private static void test() {

        List<String> strings = new ArrayList<>();
        strings.add("Mercedes");
        strings.add("BMW");
        strings.add("Honda");

        System.out.println("Array in line: " + strings);
        System.out.println("");

        for (String string : strings) {
            System.out.println("Array forEach: " + string);
        }

        System.out.println("");
        strings.forEach((string -> System.out.println("Array Lambda: " + string)));
    }

//     Стандартний підхід написання програми:
//     Головний клас звертається до інтерфейсу з абстрактиними методами, акий реалізує їх через конкретну імплементацію.
//     Якщо нам не потрібно використовувати такий складний механізм і ми реалізуємо один єдиний метод, то ми можемо
//     його реалізувати у Анонімному класі, який не відрізняєтся від звичайного класу, але він може бути реалізований
//     безпосередньо в Головному класі.
//     Анонімний клас без назви, імплементує сам себе, не потрібна від'ємна реалізація. Це клас, який реалізує один абстрактний метод.

//    int sum;
//    SumUtil sumUtilImpl = new SumUtilImpl();  // стандартний підхід, реалізуємо через клас SumUtilImpl
//    sum = sumUtilImpl.sum(3, 7);              // там вже прописаний метод по реалізаціі функції sum
//---------------------------------------------------------------------

//     Анонімний клас (new SumUtil() підсвічує сірим, тобто імені немає

//     SumUtil sumUtilAbs = new SumUtil() {     // реалізація тогож методу, але визиваємо його через анотацію, тобто
//            @Override                         // звертаємось до абстрактного методу класа SumUtil
//            public int sum(int a, int b) {    // реалізацію методу прописуємо прямо в головному класі,
//                return a + b;                 // даний метод знаходиться в класі SumUtilImpl
//            }
//      };
//      sum = sumUtilAbs.sum(3, 8);
//---------------------------------------------------------------------------------------------------------------

//      Під капотом Лямбда виразу є Анонімний клас, який реалізовує інтерфейс з одним методом,
//      тоді в Лямбді прибрали все зайве, що само собі зрозуміло, тоді ми можемо:
//      @Override прибираємо, т.я вона потрібна лише компілятору
//      public - не потрібен, т.я ми у головному класі і наружу передавати цей метод не будемо
//      int sum не потрібен, тому що відомо, тому що реалізуємо лише один конкретний абстрактний метод в класі Інтерфейс
//      new SumUtil() - не потрібен, пісвічує сірим, імені клас не має
//      return прибираємо, т.я лише однин рядок коду

//      SumUtil sumUtilLambda = (a, b) -> a + b;    // залишилося лише те, що реально описує та виконує функція
//      sum = sumUtilLambda.sum(4,8);


}
