package yugo.dao;

import yugo.entity.BaseEntity;

import java.sql.SQLException;
import java.util.Collection;
import java.util.Optional;

// інтерфейс, що реалізує абстрактні методи, безпосередньо контактує з БД. Таким чином в БД не звертаються сотні класів,
// кожен зі своєю імплементацією, а працюють через один універсальний інтерфейс.
// Один абстрактний метод може виконувати CRUD операції для різних сутностей
// дуже удобно, щоб не писати релізацію для багатьох класів
// І ТІЛЬКИ BaseDao ІДЕ ДО ЗВʼЯЗУЮЧЕГО ЗВЕНА З БАЗОЮ JdbcConnector І ОТРИМУЄ СЕСІЮ ДЛЯ КОЖНОЇ ОПЕРАЦІЇ
// щоб нащадки BaseDao мали можливість виконувати усі доступні методи, робимо його нащадком BaseEntity
public interface BaseDao <E extends BaseEntity> {

    void create (E e);
    void update (E e);
    void delete (Long id);
    Optional<E> findById(Long id);
    Collection<E> findAll() throws SQLException;
}

// для чого створили інтерфейс? просто аби був? чому одразу не зробили в ньому імплементаію?
// один програміст пише Dao класи, інший Service класи, між собою вони діють через абстрактний інтерфейс API
// програміст Dao думає як взаімодіяти з БД, програміст Service реалізовує логіку програми (додатку) і їм не важливо
// хто і як з них виконує свою роботу, їм важливо взаімодіяти через єдиний зрозумілий для них інтерфейс і все, що треба
// знати один одному, це набор і назви Методів які зрозумілі по назві, що виконують

// E findById(Long id); - у реалізації методу повертаємо конкретний обʼєкт return convertResultSetToEmployee(resultSet);,
// або return null;, - таким чином 1-ший програміст який користується цим методом, розуміє що обʼєкт обовʼязково повернеться і
// перевіряти його у себе додатково на null не треба, а якщо метод не відпрацює і буде null, то цей програміст навіть не дізнається,
// по типу того як не можна в умовах методу прописувати if o != null програма відпрацює, але метод може не виконатись, тому ми там ставили try
// для того щоб програміст бачив, що в конкретному методі щось повинне повернутися, але можливо що обʼєкта і не буде, то це йому
// натяк на те, що метод треба додатково перевірити (наприклад, на null), тому треба давати йому зрозуміти додаванням до
// методу Optional
